from fastapi import FastAPI

# Migrating from 1.* to 2.*


## How to read this guide:

This guide is intended to help your migrate existing functionality from `that-depends` version `1.*` to `2.*`.
The goal of this guide is to allow you to migrate as fast as possible, making only the minimal necessary changes
to your codebase. 

If you want to know more about new features introduced in `2.*`, please refer to the [documentation](https://that-depends.readthedocs.io/en/latest/) and 
[release notes](https://github.com/modern-python/that-depends/releases).



## Deprecated features



1. `BaseContainer.init_async_resources()` has been removed. Use `BaseContainer.init_resources()` instead.

**Example:**

If you are using containers, you likely have a similar setup to this:
```python
from that_depends import BaseContainer

class MyContainer(BaseContainer):
    # here you have defined your providers
    ...
```
Replace all instances of:
```python
await MyContainer.init_async_resources()
```
With the following:
```python
await MyContainer.init_resources()
```
2. `that_depends.providers.AsyncResource` has been removed. Use `providers.Resource` instead.

**Example:**

Replace all instances of:
```python
from that_depends.providers import AsyncResource 
my_provider = providers.AsyncResource(some_async_function)
```

With the following:
```python
from that_depends.providers import Resource
my_provider = providers.Resource(some_async_function)
```

## Changes in the API

1. `container_context()` now requires a keyword argument to set initial context.

Previously, one could initialize a global context by passing a dict to the `container_context()` context manager:


```python
my_global_context = {"some_key": "some_value"}
async with container_context(my_global_context): 
    assert fetch_context_item("some_key") == "some_value"
```

In `2.*` instead use the `global_context` keyword argument:

```python
my_global_context = {"some_key": "some_value"}
async with container_context(global_context=my_global_context):
    assert fetch_context_item("some_key") == "some_value"
```

2. `container_context(global_context=my_global_context)` no longer resets context for all resources.

Previously, when calling `container_context(my_global_context)` two things would happen:
- The global context would be set to `my_global_context`, so values from this context could be resolved using `fetch_context_item()`. This behaviour remains the same.
- A new context would be initialized for all `providers.ContextResource` instances (wherever they were defined). This behaviour no longer applies.

In `2.*` if you wish to both set a `global_context` and reset context for all resources, you also need to set `reset_all_containers=True`:


```python
async with container_context(global_context=my_global_context, reset_all_containers=True):
    assert fetch_context_item("some_key") == "some_value"
```

> Notice that `reset_all_containers=True` re-initializes the context for all `providers.ContextResource` instances defined with containers (classes that inherit from `that_depends.BaseContainer`). Unlike previously, where it would also
> reset context for `ContextResource` providers defined anywhere. If you wish to reproduce this behaviour, you will need to explicitly re-initialize the context for
> providers outside containers. For more details, please read the documentation and the [potential issues section](#potential-issues-when-using-container_context).

For further details on handling context with `2.*` please refer to the [ContextResource documentation](../providers/context-resources.md).

## Potential issues when using `container_context()`

> Please make sure that you have consulted the previous sections of this page before reading this.

If you have migrated all the previous functionality and are still experiencing issues with managing context 
resources, this might be due to the fact that entering `container_context()` does not correctly initialize context for your resources.

Here is an example of how you might have used `container_context()` in `1.*`:

```python
from that_depends import container_context

async def some_async_function():
    # you enter a new context but because `MyContainer` is imported later,
    # resources in that container are not re-initialized
    async with container_context(): 
        # now you import your container
        from some_other_module import MyContainer
        # and attempt to resolve a resource `providers`.ContextResource`
        my_resource = await MyContainer.my_context_resource.async_resolve() # ‚ùå Error!
```

In situations like this one and perhaps other similar situations where your container is outside the current scope when
entering `container_context()`, you might have to handle things differently in order to get your resources initialized.

Here are some potential suggestions:

- Pass explicit arguments to the `DIContextMiddleware`

If you are using  `DIContextMiddleware` with your ASGI-application, this now accepts additional arguments.

**Example with `fastapi`:**

```python
import fastapi
from that_depends.providers import DIContextMiddleware, ContextResource
from that_depends import BaseContainer

MyContainer: BaseContainer
my_context_resource_provider: ContextResource
my_app: fastapi.FastAPI

my_app.add_middleware(DIContextMiddleware, MyContainer, my_context_resource_provider)
```

The middleware will automatically initialize context for the provided resources when an endpoint is called.


- Avoid entering `container_context()` with no arguments passed.

You can now pass all resources that support context initialization (i.e. `providers.ContextResource` instances and `BaseContainer` subclasses) to `container_context()` explicitly.

**Example:**

```python
from that_depends import container_context

MyContainer: BaseContainer
my_context_resource_provider: ContextResource

with container_context(MyContainer, my_context_resource_provider):
    # now you can resolve resources from `MyContainer` and `my_context_resource_provider`
    my_container_instance = MyContainer.my_context_resource.sync_resolve()
    my_provider_instance = my_context_resource_provider.sync_resolve()
```

In general, it is recommended to explicitly initialize container context, since this can prevent unexpected behaviour
and speed up your code.



## Further help

If you are still having issues with migration you can either create a [discussion](https://github.com/modern-python/that-depends/discussions) or open an [issue](https://github.com/modern-python/that-depends/issues).
